# To-do 学习问题集

## Git 相关问题

### Git 概念与原理
1. 什么是分布式版本控制系统？与集中式版本控制系统有什么区别？

- 分布式版本控制是在见到集中式版本控制在连接方面的弱点之后找到的一种完美解决方案。
- 集中式版本控制是每个协作者共用一个远程库操作，或者是实时与本地服务器连接的控制系统，导致在网络不稳定等因素下无法办公的尴尬情况。
- 而分布式控制可让每个协作者本地克隆一份一模一样的模型，在本地进行提交至个人仓库（repository），任何操作不需要联网，再需要上传时push能保留所有提交版本。

2. Git 的三个工作区域（工作区、暂存区、版本库）各自的作用是什么？
- 工作区：用来修改（modifie）文件。
- 暂存区：将修改好的文件通过（add）暂时放入存储区，准备提交。
- 版本库：将暂存区的文件通过（commit），传入到本地的版本库（.git）里，而放在这里的文件都会在下一次push中传到远程。

3. Git 的提交对象（commit object）包含哪些信息？

- **提交哈希值**：40位SHA-1哈希值，唯一标识这个提交
- **作者信息**：作者姓名、邮箱、提交时间戳
- **提交者信息**：提交者姓名、邮箱、提交时间戳（可能与作者不同）
- **父提交引用**：指向父提交的哈希值（普通提交一个父提交，合并提交多个父提交）
- **提交消息**：提交的简短描述和详细说明
- **树对象引用**：指向树对象（tree object）的哈希值，包含工作目录的文件结构快照
- **完整性验证**：所有信息参与哈希计算，确保数据完整性
- **不可变性**：一旦创建，提交对象内容不可更改，任何修改都会生成新的提交对象
4. Git 的哈希值是如何生成的？为什么使用 SHA-1？

- Git 的哈希值是通过对文件内容、文件路径、提交信息等所有相关数据进行 SHA-1 哈希算法计算生成的。
- 使用 SHA-1 的原因：SHA-1 是一种密码学哈希函数，具有抗碰撞性，能够确保每个对象都有唯一的标识符。
- 40 位的十六进制字符串，足够唯一标识 Git 仓库中的任何对象。
- 任何细微的变化都会产生完全不同的哈希值，确保数据完整性。

5. Git 的分支本质上是什么？如何实现轻量级分支？

- Git 的分支本质上是一个指向提交对象的指针，指向某个特定的提交。
- 轻量级分支的实现：Git 的分支只是一个简单的文件，包含指向某个提交的哈希值。
- 创建分支时，Git 只是创建一个新的指针文件，指向当前提交，非常快速和高效。
- 分支的切换只是改变 HEAD 指针的指向，不需要复制任何文件。

6. Git 的合并策略有哪些？fast-forward 和 three-way merge 的区别？

- **Fast-forward 合并**：当目标分支没有新的提交时，直接将当前分支指向目标分支的最新提交，保持线性历史。
- **Three-way merge**：当两个分支都有新的提交时，Git 会创建一个新的合并提交，包含两个分支的共同祖先和各自的更改。
- **Recursive merge**：Git 的默认合并策略，能够处理复杂的合并情况。
- **Octopus merge**：用于合并多个分支的情况。

7. Git 的 rebase 和 merge 有什么区别？什么时候使用哪种方式？

- **Merge**：保留完整的历史记录，创建合并提交，适合公共分支的合并。
- **Rebase**：重新应用提交到新的基础分支上，创建线性历史，适合个人分支的整理。
- 使用 merge 的情况：合并公共分支、保留完整历史、处理冲突较多的合并。
- 使用 rebase 的情况：整理个人分支历史、保持线性提交历史、在合并前清理提交。

8. Git 的 stash 机制是如何工作的？

- Stash 是一个临时存储区域，用于保存工作区和暂存区的更改。
- 当需要切换分支但当前有未提交的更改时，可以使用 stash 暂存这些更改。
- Stash 会创建一个新的提交对象，保存当前的更改状态。
- 可以应用、删除、查看 stash 列表，支持多个 stash 条目。

9. Git 的 reset 和 revert 命令有什么区别？

- **Reset**：将分支指针移动到指定的提交，丢弃后续的提交历史，适合本地分支的重置。
- **Revert**：创建一个新的提交，撤销指定提交的更改，保留完整历史，适合公共分支的撤销。
- Reset 会改变历史，revert 不会改变历史。
- Reset 适合本地操作，revert 适合公共分支的安全撤销。

10. Git 的内部数据结构（blob、tree、commit、tag）是如何组织的？

- **Blob 对象**：存储文件的实际内容，不包含文件名和路径信息。
- **Tree 对象**：存储目录结构，包含文件名、权限、指向 blob 或子 tree 的引用。
- **Commit 对象**：存储提交信息，包含作者、提交者、提交消息、指向 tree 对象的引用、父提交引用。
- **Tag 对象**：为特定提交创建标签，包含标签名、标签消息、指向 commit 对象的引用。
- 这些对象通过哈希值相互引用，形成有向无环图（DAG）结构。

11. 如果我想在已经提交过的之前的地方创建分支怎么办，怎么移动HEAD？

- **创建指向历史提交的分支**：Git 允许在任何历史提交上创建新分支，只需要指定提交的哈希值或引用。
- **HEAD 指针的移动原理**：HEAD 是一个特殊的指针，指向当前工作目录对应的提交。当切换分支或重置时，HEAD 会移动到新的位置。
- **分离 HEAD 状态**：当 HEAD 直接指向某个提交而不是分支时，Git 处于"分离 HEAD"状态，此时可以创建新分支来保存更改。
- **分支创建的底层机制**：创建分支时，Git 只是创建一个新的指针文件，指向指定的提交，HEAD 会移动到新分支上。
- **历史提交的访问**：可以通过提交哈希、相对引用（如 HEAD~1）、标签等方式访问历史提交。
- **分支切换的影响**：切换分支时，工作目录会更新为对应提交的状态，HEAD 会指向新分支的最新提交。


### GitHub vs Gitee vs GitLab
1. 这三个平台在功能定位上有什么主要区别？
2. GitHub 的 Pull Request 和 GitLab 的 Merge Request 有什么不同？
3. 各平台的 CI/CD 集成方式有什么差异？
4. GitHub Actions、GitLab CI、Gitee Go 的配置语法有什么不同？
5. 各平台的代码审查功能有什么特色？
6. 如何在不同平台间迁移项目？
7. 各平台的权限管理系统有什么差异？
8. GitHub 的 Issues 和 GitLab 的 Issues 功能对比？
9. 各平台的 Wiki 和文档管理功能如何？
10. 如何选择适合自己项目的平台？

### Git 文件跟踪
1. .gitignore 文件的匹配规则有哪些？

- **精确匹配**：直接写文件名，如 `file.txt`
- **通配符匹配**：使用 `*` 和 `?`，如 `*.log`、`temp?`
- **目录匹配**：以 `/` 结尾表示目录，如 `build/`
- **路径匹配**：使用 `/` 指定路径，如 `src/temp/`
- **否定匹配**：使用 `!` 表示不忽略，如 `!important.log`
- **注释**：以 `#` 开头的行为注释

2. 如何忽略已经被 Git 跟踪的文件？

- 使用 `git rm --cached <file>` 从版本库中移除文件，但保留本地文件
- 在 .gitignore 中添加文件路径
- 使用 `git update-index --assume-unchanged <file>` 临时忽略文件
- 使用 `git update-index --skip-worktree <file>` 永久忽略文件

3. Git 如何处理二进制文件？

- Git 无法对二进制文件进行差异比较，只能存储完整文件
- 二进制文件的更改会导致存储空间快速增长
- 建议使用 Git LFS（Large File Storage）来管理大二进制文件
- 二进制文件无法进行合并操作

4. 如何查看某个文件是否被 Git 跟踪？

- 使用 `git ls-files <file>` 查看文件是否在版本库中
- 使用 `git status <file>` 查看文件状态
- 使用 `git check-ignore <file>` 检查文件是否被忽略

5. Git 的 clean 命令有什么作用？

- `git clean` 用于删除工作区中未被跟踪的文件
- `git clean -n` 预览将要删除的文件
- `git clean -f` 强制删除文件
- `git clean -d` 删除目录
- `git clean -x` 删除被忽略的文件

6. 如何强制添加被忽略的文件？

- 使用 `git add -f <file>` 强制添加被忽略的文件
- 使用 `git add --force <file>` 强制添加文件
- 临时修改 .gitignore 文件，添加文件后再恢复

7. Git 如何处理大文件？

- Git 对大文件支持有限，建议使用 Git LFS
- 大文件会导致仓库体积快速增长
- 克隆和拉取大文件会很慢
- 可以使用 `git filter-branch` 清理历史中的大文件

8. .gitattributes 文件的作用是什么？

- 设置文件的属性，如文本/二进制、换行符处理
- 配置合并策略，如 `merge=ours`
- 设置导出过滤，如 `export-ignore`
- 配置差异算法，如 `diff=text`

9. 如何设置文件的换行符处理？

- 在 .gitattributes 中设置 `* text=auto`
- 设置特定文件类型：`*.txt text`
- 设置二进制文件：`*.png binary`
- 设置换行符转换：`*.sh text eol=lf`

10. Git LFS 是什么？如何使用？

- Git LFS（Large File Storage）是 Git 的大文件存储扩展
- 将大文件存储在外部服务器，Git 只存储指针
- 安装：`git lfs install`
- 跟踪文件：`git lfs track "*.psd"`
- 提交：正常使用 `git add` 和 `git commit`

## SSH 相关问题

### SSH 概念
1. SSH 协议的工作原理是什么？
2. SSH 的加密算法有哪些？各有什么特点？
3. SSH 的认证方式有哪些？
4. SSH 的端口转发是如何工作的？
5. SSH 的密钥交换过程是怎样的？
6. SSH 的会话复用机制是什么？
7. SSH 的安全配置有哪些最佳实践？
8. SSH 的日志记录和审计功能如何？
9. SSH 的代理转发有什么作用？
10. SSH 的隧道技术有哪些应用场景？

### 公私钥管理
1. RSA、DSA、ECDSA、Ed25519 密钥算法有什么区别？
2. 如何生成不同强度的 SSH 密钥？
3. SSH 密钥的权限设置有什么要求？
4. 如何管理多个 SSH 密钥？
5. SSH 密钥的备份和恢复策略是什么？
6. 如何撤销和更换 SSH 密钥？
7. SSH 密钥的过期机制如何实现？
8. 如何实现 SSH 密钥的自动轮换？
9. SSH 密钥的硬件安全模块（HSM）支持如何？
10. 如何实现 SSH 密钥的集中管理？

## Ubuntu Shell (Bash) 相关问题

### Linux 基础
1. Linux 内核的主要组件有哪些？
2. Linux 的进程调度算法有哪些？
3. Linux 的内存管理机制是怎样的？
4. Linux 的文件系统层次结构（FHS）是什么？
5. Linux 的设备文件系统如何工作？
6. Linux 的权限模型（rwx）是如何实现的？
7. Linux 的进程间通信方式有哪些？
8. Linux 的系统调用接口是如何工作的？
9. Linux 的模块化内核有什么优势？
10. Linux 的启动过程是怎样的？

### Shell 工具
1. Bash 的内置命令和外部命令有什么区别？
2. Bash 的变量作用域和生命周期是怎样的？
3. Bash 的管道和重定向机制如何工作？
4. Bash 的作业控制功能有哪些？
5. Bash 的调试和错误处理机制如何？
6. Bash 的性能优化技巧有哪些？
7. Bash 的安全编程实践有哪些？
8. Bash 的国际化（i18n）支持如何？
9. Bash 的插件和扩展机制如何？
10. Bash 与其他 Shell（zsh、fish）的对比？

## 网络相关问题

### QoS
1. QoS 的基本概念和分类有哪些？
2. 流量整形和流量监管有什么区别？
3. QoS 的队列管理算法有哪些？
4. 如何实现带宽保证和延迟控制？
5. QoS 在不同网络层次的应用有什么不同？
6. 如何配置 Linux 系统的 QoS？
7. QoS 的监控和测量方法有哪些？
8. 软件定义网络（SDN）中的 QoS 如何实现？
9. 云环境中的 QoS 策略如何设计？
10. QoS 与网络安全的关系如何？

### SMB/NAS
1. SMB 协议的发展历程和版本差异？
2. SMB 的认证和加密机制如何？
3. SMB 的性能优化技巧有哪些？
4. NAS 的存储架构有哪些类型？
5. 如何实现 SMB 的高可用性？
6. SMB 的权限管理和访问控制如何？
7. SMB 的备份和恢复策略是什么？
8. SMB 在虚拟化环境中的应用如何？
9. SMB 与 NFS 的对比分析？
10. SMB 的安全配置最佳实践有哪些？

## 计算机视觉相关问题

### 流媒体
1. 流媒体协议（RTMP、HLS、DASH）的对比分析？
2. 实时流媒体和点播流媒体的技术差异？
3. 流媒体的自适应码率技术如何实现？
4. 流媒体的延迟优化策略有哪些？
5. 流媒体的错误恢复和容错机制如何？
6. 流媒体的负载均衡和扩展性如何实现？
7. 流媒体的加密和 DRM 技术有哪些？
8. 流媒体的质量评估指标有哪些？
9. 流媒体的网络传输优化技巧？
10. 流媒体的移动端适配策略？

### RTSP
1. RTSP 协议的状态机和消息流程？
2. RTSP 与 RTP、RTCP 的关系如何？
3. RTSP 的会话管理和资源控制？
4. RTSP 的认证和安全机制？
5. RTSP 的代理和网关技术？
6. RTSP 的性能优化和扩展性？
7. RTSP 的故障排查和调试方法？
8. RTSP 在物联网中的应用？
9. RTSP 的标准化和兼容性？
10. RTSP 的未来发展趋势？

## 机器学习相关问题

### 数据集
1. Kaggle 平台的核心功能和使用技巧？
2. Hugging Face 的数据集和模型生态系统？
3. 数据标注的质量控制和验证方法？
4. 数据集版本管理和数据血缘追踪？
5. 大规模数据集的处理和存储策略？
6. 数据集的隐私保护和匿名化技术？
7. 数据集的市场和商业化模式？
8. 数据集的法律和伦理问题？
9. 数据集的标准和互操作性？
10. 数据集的生命周期管理？

### 框架
1. Keras 的高级 API 和自定义层开发？
2. Scikit-learn 的管道和特征工程？
3. 深度学习框架的性能对比和选择？
4. 模型部署和服务的架构设计？
5. 分布式训练和模型并行化？
6. 模型压缩和量化技术？
7. 自动机器学习（AutoML）的实现？
8. 模型的可解释性和公平性？
9. 边缘计算中的模型优化？
10. 机器学习平台的 MLOps 实践？

## NLP 相关问题

### 中英文差异
1. 中文分词的技术挑战和解决方案？
2. 中英文的词序和语法结构差异？
3. 中文的语义理解和歧义消解？
4. 中英文的命名实体识别差异？
5. 中文的句法分析和依存关系？
6. 中英文的机器翻译技术差异？
7. 中文的语音识别和合成特点？
8. 中英文的文本生成和对话系统？
9. 中文的预训练语言模型发展？
10. 中英文 NLP 的评估指标差异？

### HanLP
1. HanLP 的架构设计和模块化？
2. HanLP 的自定义词典和规则？
3. HanLP 的模型训练和微调？
4. HanLP 的性能优化和并行化？
5. HanLP 的插件开发和扩展？
6. HanLP 的部署和服务化？
7. HanLP 的版本管理和兼容性？
8. HanLP 的社区和生态系统？
9. HanLP 的商业化应用案例？
10. HanLP 的未来发展方向？

## Docker 相关问题

### Docker vs VM
1. 容器和虚拟机的技术架构差异？
2. 容器和虚拟机的性能对比分析？
3. 容器和虚拟机的资源隔离机制？
4. 容器和虚拟机的安全模型差异？
5. 容器和虚拟机的网络实现方式？
6. 容器和虚拟机的存储管理差异？
7. 容器和虚拟机的启动时间和资源占用？
8. 容器和虚拟机的可移植性对比？
9. 容器和虚拟机的监控和调试？
10. 容器和虚拟机的适用场景选择？

### Podman
1. Podman 与 Docker 的兼容性分析？
2. Podman 的无守护进程架构优势？
3. Podman 的 rootless 容器技术？
4. Podman 的安全特性和 SELinux 集成？
5. Podman 的镜像管理和构建？
6. Podman 的网络和存储配置？
7. Podman 的编排和 Kubernetes 集成？
8. 从 Docker 迁移到 Podman 的策略？
9. Podman 的性能优化和最佳实践？
10. Podman 的企业级应用场景？

## Jupyter Notebook 相关问题

### 使用方法
1. Jupyter 的架构和组件关系？
2. Jupyter 的内核管理和多语言支持？
3. Jupyter 的扩展开发和插件系统？
4. Jupyter 的权限管理和多用户支持？
5. Jupyter 的版本控制和协作功能？
6. Jupyter 的性能优化和资源管理？
7. Jupyter 的安全配置和访问控制？
8. Jupyter 的备份和恢复策略？
9. Jupyter 的监控和日志管理？
10. Jupyter 的容器化部署方案？

### 参考资料
1. Jupyter 的官方文档和教程资源？
2. Jupyter 的社区和生态系统？
3. Jupyter 的最佳实践和设计模式？
4. Jupyter 的故障排查和调试技巧？
5. Jupyter 的集成开发环境配置？
6. Jupyter 的自动化工作流程？
7. Jupyter 的学术和教育应用？
8. Jupyter 的商业化和企业应用？
9. Jupyter 的开源贡献和开发？
10. Jupyter 的未来技术发展趋势？
